<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<style>
    .container {
        width: 650px;
        height: 500px;
        background-color: aqua;
        margin:auto;
    }

    .aside {
        width: 150px;
        height: 100%;
        background-color: pink;
        float:left;        
    }
        .aside input {
            width: 90%;
        }

        .aside button {
            width: 40%;
        }

    .content {
        width: 500px;
        height: 100%;
        background-color: greenyellow;
        float:left;
    }

</style>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script>
/*목록을 출력하는 작업은 꼭 등록할때만이 아니라 유저가 처음 브라우저로 mail.html요청한 시점부터도 목록이 나와야 하므로 목록기능은 재사용 가능성이 높다
 * 따라서 함수로 별도로 정의
 */
function render(list){
	console.log("전달받은 배열은 ", list);
	// 렌더링 작업은 상당히 고달픈 작업이면서 시간이 많이 걸림
	// 따라서 이와 관련되어 나온 기술이 Vue, React.js등등이 등장
	// 바닐라 스크립트 => document.querySelector(".content").innerHTML="<table>";
	
	let tag ="<table width='100%' border='1px'>";
	tag+="<thead>";
	tag+="<tr>"
	tag+="<th>ID</th>";
	tag+="<th>Name</th>";
	tag+="<th>Email</th>";
	tag+="</tr>";
	tag+="</thead>";
	tag+="<tbody>";
	
	
	// 숙제!! 반복문 돌리기!!! 반복문 떠오르자마자 for던 while이던 틀 먼저 구해두고(반복문 돌릴 구역 나누기) 그 후 들여쓰기하고나서 시작!!!!
	for(let i = 0 ; i < list.length; i++){ // js문법에 맞춰 작성해야함에 주의!!
	let member = list[i]; // 한명의 회원을 꺼냄
	tag+="<tr>";
	tag+="<th>"+list[i].id+"</th>";
	tag+="<th>"+list[i].name+"</th>";
	tag+="<th>"+list[i].email+"</th>";
	tag+="</tr>";
	}
	
	tag+="</tbody>";
	tag +="</table>";
	$(".content").html(tag);
	
}

// 서버에 목록 요청(비동기적)
function getList(){
	// 비동기적 요청을 담당하는 XMLHttpRequest객체들 사용
	let xhttp = new XMLHttpRequest();
	
	// 서버의 응답이 도달하면 지정한 익명함수가 호출됨(by javascript)
	xhttp.onload=function(){
		// 서버에서 전송한 json문자열을 파싱하여 화면에 렌더링하자
		console.log("서버가 응답한 데이터는 ", this.responseText);
		
		// 파싱 시 주의점? 반드시 문자열dl JSON표기법을 따른 것만이 파싱을 성공할 수 있다.
		let memberList  = JSON.parse(this.responseText); 
		
		// 화면에 렌더링
		render(memberList);
	};
	
	
	xhttp.open("GET", "/ajax/async_list.jsp"); // 요청 준비
	xhttp.send(); // 여기서 요청 발생
	
}


function regist(){
	// 서버에 요청을 시도하되, 비동기로 요청하자.
	let xhttp = new XMLHttpRequest(); // JS의 비동기 통신 객체
	
	xhttp.onload=function(){
		// 서버에서 응답 정보가 도착하면 호출되는 표기법=>익명함수(역할=>콜백함수)
		// console.log("서버에서 보내온 데이터는 ", this.responseText);
		
		// 받아온 데이터는 언제나 문자열이므로 oop식으로 제어하려면 파싱하자!!
		// let memberList = JSON.parse(this.responseText);
		// console.log("서버에서 보내온 데이터는 ", memberList);
		
		// 서버에서 가져온 데이터를 화면에 출력
		// getList(memberList);
		console.log("등록 완료");
		
		getList(); // 등록완료와 동시에 다시 비동기적 요청시도
		
	}

	
	xhttp.open("POST", "/ajax/async_regist.jsp");
	xhttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded","charset=utf-8"); // 전송 시 헤더 지정
	xhttp.send("id=" + $("input[name='id']").val() + "&name=" + $("input[name='name']").val() + "&email=" + $("input[name='email']").val());
	// 비동기 요청 출발~!! => 이 떄 요청 시도 자체를 자바 스크립트가 하지 않고 브라우저에게 시킴
	// 자바스크립트는 응답정보가 올 때까지 대기상태에 빠지지 않고 자신의 다른 일을 할 수 있다(비동기!)
	// 응답이 올 때까지 기다리지 않았기 때문에, 즉, 순서를 지키지 않았기 때문에 비동기 방식!
	// 브라우저가 응답을 받아오면, 자바스크립트에게 알림. 이 때 자바스크립트의 XMLHttpRequest의 onload속성에 지정한 익명함수인 콜백함수를 호출하게 된다.
	// 누가? js가!!
	
}


$(()=>{
	
	$("button").click(()=>{
		regist();
	});
	getList();
});

// 문서가 로드되면 기존에 누적된 데이터를 비동기적으로 가져오자



</script>
</head>
<body>
    <div class="container">
        <div class="aside">
            <form>
                <input type="text" placeholder="Your ID" name="id">
                <input type="text" placeholder="Your name" name="name">
                <input type="text" placeholder="Your email" name="email">
                <button type="button">등록</button>
            </form>
        </div>
        <div class="content"></div>
    </div>
</body>
</html>